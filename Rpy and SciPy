\documentclass[a4paper,12pt]{article}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\usepackage{eurosym}
\usepackage{vmargin}
\usepackage{amsmath}
\usepackage{graphics}
\usepackage{epsfig}
\usepackage{framed}
\usepackage{subfigure}
\usepackage{fancyhdr}

\setcounter{MaxMatrixCols}{10}
%TCIDATA{OutputFilter=LATEX.DLL}
%TCIDATA{Version=5.00.0.2570}
%TCIDATA{<META NAME="SaveForMode"CONTENT="1">}
%TCIDATA{LastRevised=Wednesday, February 23, 201113:24:34}
%TCIDATA{<META NAME="GraphicsSave" CONTENT="32">}
%TCIDATA{Language=American English}

\pagestyle{fancy}
\setmarginsrb{20mm}{0mm}{20mm}{25mm}{12mm}{11mm}{0mm}{11mm}
\lhead{RPy and SciPy} \rhead{Kevin O'Brien} \chead{StatsLabDublin} %\input{tcilatex}

%http://www.electronics.dit.ie/staff/ysemenova/Opto2/CO_IntroLab.pdf
\begin{document}

\tableofcontents
\newpage
%-----------------------------------------------------------------------------------------%
\section{About RPy2}

\begin{itemize}
\item rpy2 is a redesign and rewrite of rpy. 
\item It is providing a low-level interface to R, a proposed high-level interface, including wrappers to graphical libraries, as well as R-like structures and functions.
\end{itemize}

\subsection{Documentation}

rpy2 has a growing documentation, with documentation pages for each released or developped version.

Contact: The rpy mailing-list, questions/answers boards such as stackoverflow should be used for most of the questions.Use the contacts page otherwise.
\newpage
%-----------------------------------------------------------------------------------------%

\section{Quick Tutorial on RPy Package for R/Python Interface}

%Professor Norm Matloff
%Dept. of Computer Science
%University of California at Davis
%Davis, CA 95616

Contents of this site:

\begin{itemize}
\item Installing RPy
\item Introduction to using RPy
\item What is RPY?
\end{itemize}

%-----------------------------------------------------------------------------------------%
\subsection{What is RPy?}
RPy is a simple, easy-to-use interface to \texttt{R} from Python. It enables one to enjoy the elegance of Python programming while having access to the rich graphical and statistical capabilities of R.

In its simplest form, shown here, one includes in one's Python code a statement

from rpy2.robjects import r
This launches an execution of R, with communication to the original Python program. The Python class instance r includes various functions for remote execution of R commands, including those involved with data produced by the Python program.

IMPORTANT NOTE: The material here concerns RPy2, not the original RPy.

%-----------------------------------------------------------------------------------------%
\subsection{Installing RPY}


Dowload RPy from the RPY home page. Unpack it, and in the top directory created by the package, open a shell/command window and run
\begin{verbatim}
python setup.py install
\end{verbatim}

If you are on a multiuser system and do not have root privileges, you can specify a nondefault root directory. For example, on the UC Davis Computer Science Department's instructional machines, I typed
%--------------------------------------------------------------------------------------------%

\begin{verbatim}
R RHOME
setenv RHOME /usr/lib/R
python setup.py install --root /home/matloff/Pub/rpy2
\end{verbatim}
The first command ran R with a request to report where R was installed on the system, which turned out to be /usr/lib/R. The second command set the corresponding shell environment variable (C shell in my case). The third command specified a nondefault installation directory.

\section{Introduction to using RPY:}

First, make sure the RPy module is in your Python path. In the above context, I typed
\begin{verbatim}
setenv PYTHONPATH /home/matloff/Pub/rpy2/usr/lib/python2.5/site-packages/
\end{verbatim}
Now, let's generate vectors x and y in R, do a scatter plot, fit a least-squares line, etc.:

\begin{framed}
\begin{verbatim}
>>> from rpy2.robjects import r
>>> r('x <- rnorm(100)')  # generate x at R
>>> r('y <- x + rnorm(100,sd=0.5)')  # generate y at R
>>> r('plot(x,y)')  # have R plot them
>>> r('lmout <- lm(y~x)')  # run the regression
>>> r('print(lmout)')  # print from R
>>> loclmout = r('lmout') # download lmout from R to Python
>>> print loclmout  # print locally
>>> print loclmout.r['coefficients']  # print one component
\end{verbatim}
\end{framed}


%----------------------------------------------------------------------------------------%
Now let's apply some \texttt{R} operations to some Python variables:

\begin{framed}
\begin{verbatim}
>>> u = range(10)  # set up another scatter plot, this one local
>>> e = 5*[0.25,-0.25]
>>> v = u[:]
>>> for i in range(10): v[i] += e[i]
>>> r.plot(u,v)
>>> r.assign('remoteu',u)  # ship local u to R
>>> r.assign('remotev',v)  # ship local v to R
>>> r('plot(remoteu,remotev)')  # plot there
\end{verbatim}
\end{framed}
%----------------------------------------------------------------------------------------%
There are many more functions. See the RPy documentation for details.

%---------------------------------------------------------------------------------------------------------%
\newpage
\section{A Demonstration of RPy: Tim Churches}

RPy, written by Walter Moreira and maintained by Gregory Warnes, is a Python extension module for using the R programming environment for data analysis and graphics from within Python.

RPy is available from the RPy project web page. As Walter notes, RPy was inspired by RSPython by Duncan Temple Lang. RSPython allows R to be called from Python and vice-versa (i.e. Python can be embedded in R), as well as providing more general facilities for exploiting the object-oriented aspects of both Python and R. However, at least for me, RPy is a lot easier to use. It is my sincere hope that RPy and RSPython can be merged in a display of el Norte/el Sur co-operation, so we can have the best of both.

The following example provides a small taste of both the power of the R environment and the ease with which RPy allows this power to be used from within Python.
\subsubsection{Old Faithful Example}
The data are eruption times for the Old Faithful geyser which, along with Yogi Bear, is located in the Yellowstone National Park in Wyoming, USA. The data file faithful.dat was exported from the faithful example dataset which comes as part of R. The R code in this example was borrowed directly from Section 8.2 of "An Introduction to R, Version 1.4.1" by W.N. Venables, D.M. Smith and the R Development Core Team. Minimal changes to the orginal R code were required to make it work from within Python, thanks to RPy.

The following Python code (faithful.py):
\begin{verbatim}
from rpy import *

faithful_data = {"eruption_duration":[],
                 "waiting_time":[]}
		
f = open('faithful.dat','r')

for row in f.readlines()[1:]: # skip the column header line
    splitrow = row[:-1].split(" ")
    faithful_data["eruption_duration"].append(float(splitrow[0]))
    faithful_data["waiting_time"].append(int(splitrow[1]))

f.close()

ed = faithful_data["eruption_duration"]
edsummary = r.summary(ed)
print "Summary of Old Faithful eruption duration data"
for k in edsummary.keys():
    print k + ": %.3f" % edsummary[k]
print
print "Stem-and-leaf plot of Old Faithful eruption duration data"
print r.stem(ed)

r.png('faithful_histogram.png',width=733,height=550)
r.hist(ed,r.seq(1.6, 5.2, 0.2), prob=1,col="lightgreen",
       main="Old Faithful eruptions",xlab="Eruption duration (seconds)")
r.lines(r.density(ed,bw=0.1),col="orange")
r.rug(ed)
r.dev_off()

long_ed = filter(lambda x: x > 3, ed)
r.png('faithful_ecdf.png',width=733,height=550)
r.library('stepfun')
r.plot(r.ecdf(long_ed), do_points=0, verticals=1, col="blue",
       main=paste("Empirical cumulative distribution function",
                  " of Old Faithful eruptions longer than 3 seconds")
x = r.seq(3,5.4,0.01)
r.lines(r.seq(3,5.4,0.01),r.pnorm(r.seq(3,5.4,0.01),mean=r.mean(long_ed),
        sd=r.sqrt(r.var(long_ed))), lty=3, lwd=2, col="red")
r.dev_off()
\end{verbatim}
%--------------------------------------------------------------------------%
\newpage
\begin{framed}
\begin{verbatim}
r.png('faithful_qq.png',width=733,height=550)
r.par(pty="s")
r.qqnorm(long_ed,col="blue")
r.qqline(long_ed,col="red")
r.dev_off()

r.library('ctest')
print
print("Shapiro-Wilks normality test of Old Faithful eruptions" +\
      " longer than 3 seconds")
sw = r.shapiro_test(long_ed)
print "W = %.4f" % sw['statistic']['W']
print "p-value = %.5f" % sw['p.value']

print
print("One-sample Kolmogorov-Smirnov test of Old Faithful eruptions" +\
      " longer than 3 seconds"
ks = r.ks_test(long_ed,"pnorm", mean=r.mean(long_ed),
               sd=r.sqrt(r.var(long_ed)))
print "D = %.4f" % ks['statistic']['D']
print "p-value = %.4f" % ks['p.value']
print "Alternative hypothesis: %s" % ks['alternative']
print
\end{verbatim}
\end{framed}
produces the following output:

\begin{verbatim}
Summary of Old Faithful eruption duration data
Mean: 3.488
Median: 4.000
3rd Qu.: 4.454
1st Qu.: 2.163
Min.: 1.600
Max.: 5.100
\end{verbatim}


Stem-and-leaf plot of Old Faithful eruption duration data
\begin{verbatim}
  The decimal point is 1 digit(s) to the left of the |

  16 | 070355555588
  18 | 000022233333335577777777888822335777888
  20 | 00002223378800035778
  22 | 0002335578023578
  24 | 00228
  26 | 23
  28 | 080
  30 | 7
  32 | 2337
  34 | 250077
  36 | 0000823577
  38 | 2333335582225577
  40 | 0000003357788888002233555577778
  42 | 03335555778800233333555577778
  44 | 02222335557780000000023333357778888
  46 | 0000233357700000023578
  48 | 00000022335800333
  50 | 0370

None

Shapiro-Wilks normality test of Old Faithful eruptions longer than 3 seconds
W = 0.9793
p-value = 0.01052

One-sample Kolmogorov-Smirnov test of Old Faithful eruptions longer than 3 seconds
D = 0.0661
p-value = 0.4284
Alternative hypothesis: two.sided
\end{verbatim}

%------------------------------------------------------------------------------------------------------------%
\newpage
\section{History of SciPy}
This page sketches the history of SciPy and should clarify the differences/relations between SciPy, Numeric, numarray, NumPy and other related packages/projects.

\subsection{The birth of Numeric}
In the beginning there was Numeric. It was originally written in 1995 largely by Jim Hugunin with the help of many people including Jim Fulton, David Ascher, Paul DuBois, and Konrad Hinsen. Unfortunately, Numeric acquired several nicknames: Numerical Python, Numerical, NumPy. For example, the SourceForge project name for it is numpy, the old CVS module is Numerical, Konrad Hinsen named his package ScientificPython in reference to Numerical Python.
Quoting Paul DuBois on the history behind the various names of the project:
Here's the true story about why the various names for the original: numpy, Numeric, Numerical.
At the time Source Forge was pretty young, and I decided to put the project there. We all said 'numpy' informally not Numerical Python but the module name was Numeric. I created the project as numpy. I have no memory of why I didn't call it Numeric, but if it wasn't a conflict, probably I was focused on making it clear it was for Python and/or easy to type. (the FTP's etc. all had to go through a long directory path that involved the name). The documentation for the CVS stuff was confusing, and I made a mistake with my first submit of 'Numeric' (I think it was ending up with everything in Numeric/Numeric) and then discovered I could not delete it; you had to ask the Source Forge staff. Impatient, I did a second submit as Numerical.
In short, all my fault, but then again, SF was so security-minded that it was hard to do anything. That's why I soon gave up on their website and hosted it at my own site for so long.
\subsection{The birth of SciPy}
Several people used Numeric as a base for their scientific code and developed their own modules. Around 2001, Travis Oliphant, Eric Jones and Pearu Peterson merged their modules in one scientific super package: SciPy was born.
\subsection{The birth of numarray}
Development on Numeric slowed down and people wanted to extend it in ways that the then-current codebase did not really allow. Furthermore, there was a desire to get Numeric or something like it into the standard library, but Guido van Rossum (the father of Python) was quite clear that the code was not maintainable in its state then.
As a result, numarray was created by Perry Green?eld, Todd Miller and Rick White at the Space Science Telescope Institute as a replacement for Numeric. The new numarray pushed some of the code up into the Python level, which gave numarray a lot of flexibility and allowed it to experiment with a number of alternatives that have proven their usefulness. It also was quite fast for very large arrays because the people working on it were at the Space Telescope Science Institute and were intending to use it for astronomical image processing.
The split: Numeric vs. numarray
Unfortunately, as fast as it was for large arrays, numarray was too slow for small arrays. Furthermore, the C API of numarray for creating ufuncs was not as convenient as that of Numeric. This made it difficult to convert the SciPy codebase to use numarray instead of Numeric. This split fractured the community quite a bit: some people wrote code only for numarray, seeing it as the next Numeric, while other people wrote code for Numeric, because they needed SciPy.
%-----------------------------------------------------------------------------%
\subsection{The reunion, aka the birth of NumPy}
In early 2005, Travis Oliphant wanted to reunify the community around a single array package. He refactored the code of Numeric to make it more maintainable and flexible enough to implement the novel features of numarray. He named this new multi dimensional array project SciPy core and intended to use this in the bigger scientific package SciPy.
The problem with this approach was that people were mistakenly thinking that Numeric had been subsumed into SciPy and that they would have to install SciPy as a whole just to get an array object. There was a long discussion about a better name for this new multidimensional array package. The winning name was numerix, but this name turned out to be trademarked by a company that does DSP. In order to avoid trademark infringement, another name was picked: 'NumPy'.


%-----------------------------------------------------------------------------%
\subsection{Inclusion of a Numpy in Python's standard library}
In the opinion of many involved in the Numpy development, an N-dimensional array interface should be part of the Python standard libraries. Hence, a PEP was started to describe what exactly is meant by an array interface, and a webpage was set up with useful information. At the SciPy conference in 2006, Guido and Travis discussed which parts of NumPy should go into Python. They decided that the best course to pursue is to write a series of PEPs to get
the data-type object into Python
extend the buffer interface with the array interface.

\newpage
\section{SciPy}
%-----------------------------------------------------------------------------%
SciPy is an open source library of algorithms and mathematical tools for the Python programming language that grew out of Travis Oliphant's original collection of extension modules for Python which he released in 1999 under the name Multipack (named for the netlib packages that it brought together such as ODEPACK, QUADPACK, and MINPACK). Pearu Peterson was also doing work in using an automatic fortran-to-python connection tool called f2py to connect LAPACK and BLAS to Python. In 2001, Travis Oliphant, Eric Jones and Pearu Peterson merged their modules to create the SciPy package itself.[1][2] Since 2001 many contributors have joined to improve both the quality and mathematical coverage of the SciPy package. Many of these developers meet at SciPy conferences held throughout the world.
SciPy contains modules for optimization, linear algebra, integration, interpolation, special functions, FFT, signal and image processing, ODE solvers and other tasks common in science and engineering. It has a similar audience to applications such as MATLAB, GNU Octave, and Scilab.
SciPy is currently distributed under the BSD license and its development is sponsored by an open community of developers.

%-----------------------------------------------------------------------------%
\subsection{About SciPy}
SciPy (Scientific Python) is a mathematical library written in Python + C + Fortran code, well-known for Python language programmers, based on NumPy and done by about the same programmers.

\subsubsection{Available subpackages:}
\begin{itemize}
\item constants: Physical constants and conversion factors
\item cluster: Vector Quantization / Kmeans
\item fftpack: Discrete Fourier Transform algorithms
\item integrate: Integration routines
\item interpolate: Interpolation Tools
\item io: Data input and output
\item lib: Python wrappers to external libraries
l\item inalg: Linear algebra routines
\item misc: Miscellaneous utilities
\item optimize: Optimization Tools
\item sandbox: Experimental code
\item signal: Signal Processing Tools
\item sparse: Sparse Matrix Support
\item special: Special Functions
\item stats: Statistical Functions
\item weave: Allows the inclusion of C/C++ within Python code
\end{itemize}

%-----------------------------------------------------------------------------%
\subsection{SciPy optimization solvers}
All solvers from scipy.optimize can be separated into 2 categories:
connected solvers (written in C or Fortran by numerical optimization professionals, e.g. cobyla, slsqp, tnc, lbfgsb)
unconstrained solvers (or box-bounded, e.g. fminbound, brute and anneal), written in Python by SciPy folk after "Numerical Recipes" or kind of, with some tens of code lines and quality near a student homework.
Usually \textbf{\textit{interalg}} and \textbf{\textit{ralg}} for small- and medium-scaled problems, as well as gsubg for large-scale ones, and, of course, mature IPOPT and algencan show much better results (better final point, and very often much less time elapsed). But if you have a puny problem with small number of variables and without any specialties (ill-conditioned, badly-scaled etc), you could use any one. The scipy solvers were connected from the very beginning of OpenOpt development, when others were absent yet, and still remain in OpenOpt to enable easy comparison for those who want to perform it, mostly estimating pros and cons of migrating from module scipy.optimize to OpenOpt. But we don't recommend to store them in your code - even if they work well now, they don't provide any guarantee of good enough results for slightly modified problems (in future, probably by other programmers), where any specialties mentioned above may raise, as it was observed for many times.
%-----------------------------------------------------------------------------%
\subsection{Additional functionality}
SciPy's core feature set is extended by many other dedicated software tools. For example,
Plotting. The currently recommended 2-D plotting package is Matplotlib, however, there are many other plotting packages such as HippoDraw, Chaco, and Biggles. Other popular graphics tools include Python Imaging Library and MayaVi (for 3D visualization).




\section{Advanced Data Analysis}. Via RPy, SciPy can interface to the R (programming language) statistical package for advanced data analysis.
Database. SciPy can interface with PyTables, a hierarchical database package designed to efficiently manage large amounts of data using HDF5.
Interactive shell. IPython is an interactive environment that offers debugging and coding features similar to what MATLAB offers.
Symbolic Mathematics. There are several Python libraries--such as PyDSTool Symbolic and SymPy--that offer symbolic mathematics.

\subsection{SciPy References}

\begin{itemize}
\item SciPy homepage: http://scipy.org
\item Wikipedia entry for SciPy: http://en.wikipedia.org/wiki/SciPy
\end{itemize}

%----------------------------------------------------------------------------------------%
\newpage
\section{SciPy: A scientific computing package for Python}

Available subpackages:
\begin{verbatim}
__core_config__
__scipy_config__
__svn_version__
_import_tools
core_version
fft, fft2, fftn -- discrete Fourier transform. Also see fftshift, fftfreq.
fftpack (package)
integrate (package)
interpolate (package)
io (package)
lib (package)
linalg (package)
old__init__
optimize (package)
scipy_version
sparse (package)
special (package)
stats (package)
test (package)
utils (package)
\end{verbatim}

\newpage
\section{NumPy}
%---------------------------------------------------------------------------------------------------------------%
\begin{enumerate}
\item	Prerequisites
\item	The Basics
\item	An example
\item	Array Creation
\item	Printing Arrays
\item	Basic Operations
\item	Universal Functions
\item	Indexing, Slicing and Iterating
\item	Shape Manipulation
\item	Changing the shape of an array
\item	Stacking together different arrays
\item	Splitting one array into several smaller ones
\item	Copies and Views
\item	No Copy at All
\item	View or Shallow Copy
\item	Deep Copy
\item	Functions and Methods Overview
\item	Less Basic
\item	Broadcasting rules
\item	Fancy indexing and index tricks
\item	Indexing with Arrays of Indices
\item	Indexing with Boolean Arrays
\item	The $ix$ function
\item	Indexing with strings
\item	Linear Algebra
\item	Simple Array Operations
\item	The Matrix Class
\item	Indexing: Comparing Matrices and 2D Arrays
\item	Tricks and Tips
\item	"Automatic" Reshaping
\item	Vector Stacking
\item	Histograms
\item	References
\end{enumerate}
\newpage
%--------------------------------------------------------------------------------------%

\subsection{Prerequisites}
Before reading this tutorial you should know a bit of Python. If you would like to refresh your memory, take a look at the Python tutorial.
If you wish to work the examples in this tutorial, you must also have some software installed on your computer. Minimally:
\begin{itemize}
\item Python
\item NumPy
\end{itemize}
These you may find useful:

\begin{itemize}
\item ipython is an enhanced interactive Python shell which is very convenient for exploring NumPy's features
\item matplotlib will enable you to plot graphics
\item SciPy provides a lot of scientific routines that work on top of NumPy
\end{itemize}

\subsection{The Basics of NumPy}
NumPy's main object is the homogeneous multidimensional array. It is a table of elements (usually numbers), all of the same type, indexed by a tuple of positive integers. In Numpy dimensions are called axes. The number of axes is rank.
For example, the coordinates of a point in 3D space [1, 2, 1] is an array of rank 1, because it has one axis. That axis has a length of 3. In example pictured below, the array has rank 2 (it is 2-dimensional). The first dimension (axis) has a length of 2, the second dimension has a length of 3.

%---------------------------------%
\begin{verbatim}
[[ 1., 0., 0.],
 [ 0., 1., 2.]]
\end{verbatim}




%---------------------------------%
\subsection{ndarray}
Numpy's array class is called ndarray. It is also known by the alias array. Note that numpy.array is not the same as the Standard Python Library class array.array, which only handles one-dimensional arrays and offers less functionality. The more important attributes of an ndarray object are:
\textbf{ndarray.ndim}
the number of axes (dimensions) of the array. In the Python world, the number of dimensions is referred to as rank.
\textbf{ndarray.shape}
the dimensions of the array. This is a tuple of integers indicating the size of the array in each dimension. For a matrix with n rows and m columns, shape will be (n,m). The length of the shape tuple is therefore the rank, or number of dimensions, ndim.
\textbf{ndarray.size}
the total number of elements of the array. This is equal to the product of the elements of shape.
\textbf{ndarray.dtype}
an object describing the type of the elements in the array. One can create or specify dtype's using standard Python types. Additionally NumPy provides types of its own. numpy.int32, numpy.int16, and numpy.float64 are some examples.
\textbf{ndarray.itemsize}
the size in bytes of each element of the array. For example, an array of elements of type float64 has itemsize 8 (=64/8), while one of type complex32 has itemsize 4 (=32/8). It is equivalent to ndarray.dtype.itemsize.
ndarray.data
the buffer containing the actual elements of the array. Normally, we won't need to use this attribute because we will access the elements in an array using indexing facilities.
\subsubsection{An example}
\begin{verbatim}
>>> from numpy  import *
>>> a = arange(15).reshape(3, 5)
>>> a
array([[ 0,  1,  2,  3,  4],
       [ 5,  6,  7,  8,  9],
       [10, 11, 12, 13, 14]])
>>> a.shape
(3, 5)
>>> a.ndim
2
>>> a.dtype.name
'int32'
>>> a.itemsize
4
>>> a.size
15
>>> type(a)
numpy.ndarray
>>> b = array([6, 7, 8])
>>> b
array([6, 7, 8])
>>> type(b)
numpy.ndarray
\end{verbatim}

%-----------------------------------------------------------------------------------%
\subsection{Array Creation}
There are several ways to create arrays.
For example, you can create an array from a regular Python list or tuple using the array function. The type of the resulting array is deduced from the type of the elements in the sequences.
\begin{verbatim}
>>> from numpy  import *
>>> a = array( [2,3,4] )
>>> a
array([2, 3, 4])
>>> a.dtype
dtype('int32')
>>> b = array([1.2, 3.5, 5.1])
>>> b.dtype
dtype('float64')
\end{verbatim}

%-------------------------------------------------------------------------------------%
A frequent error consists in calling array with multiple numeric arguments, rather than providing a single list of numbers as an argument.
\begin{verbatim}
>>> a = array(1,2,3,4)    # WRONG

>>> a = array([1,2,3,4])  # RIGHT
\end{verbatim}

The command \texttt{array} transforms sequences of sequences into two-dimensional arrays, sequences of sequences of sequences into three-dimensional arrays, and so on.
\begin{verbatim}
>>> b = array( [ (1.5,2,3), (4,5,6) ] )
>>> b
array([[ 1.5,  2. ,  3. ],
       [ 4. ,  5. ,  6. ]])
\end{verbatim}
The type of the array can also be explicitly specified at creation time:
\begin{verbatim}
>>> c = array( [ [1,2], [3,4] ], dtype=complex )
>>> c
array([[ 1.+0.j,  2.+0.j],
       [ 3.+0.j,  4.+0.j]])
\end{verbatim}


Often, the elements of an array are originally unknown, but its size is known. Hence, NumPy offers several functions to create arrays with initial placeholder content. These minimize the necessity of growing arrays, an expensive operation.
The function zeros creates an array full of zeros, the function ones creates an array full of ones, and the function empty creates an array whose initial content is random and depends on the state of the memory. By default, the dtype of the created array is float64.
\begin{verbatim}
>>> zeros( (3,4) )
array([[0.,  0.,  0.,  0.],
       [0.,  0.,  0.,  0.],
       [0.,  0.,  0.,  0.]])
>>> ones( (2,3,4), dtype=int16 )                # dtype can also be specified
array([[[ 1, 1, 1, 1],
        [ 1, 1, 1, 1],
        [ 1, 1, 1, 1]],
       [[ 1, 1, 1, 1],
        [ 1, 1, 1, 1],
        [ 1, 1, 1, 1]]], dtype=int16)
>>> empty( (2,3) )
array([[  3.73603959e-262,   6.02658058e-154,   6.55490914e-260],
       [  5.30498948e-313,   3.14673309e-307,   1.00000000e+000]])
\end{verbatim}
%-----------------------------------------------------------------------------------------------------------------%


To create sequences of numbers, NumPy provides a function analogous to range that returns arrays instead of lists
\begin{verbatim}
>>> arange( 10, 30, 5 )
array([10, 15, 20, 25])
>>> arange( 0, 2, 0.3 )                 # it accepts float arguments
array([ 0. ,  0.3,  0.6,  0.9,  1.2,  1.5,  1.8])
\end{verbatim}


When arange is used with floating point arguments, it is generally not possible to predict the number of elements obtained, due to the finite floating point precision. For this reason, it is usually better to use the function linspace that receives as an argument the number of elements that we want, instead of the step:
\begin{verbatim}
>>> linspace( 0, 2, 9 )                 # 9 numbers from 0 to 2
array([ 0.  ,  0.25,  0.5 ,  0.75,  1.  ,  1.25,  1.5 ,  1.75,  2.  ])
>>> x = linspace( 0, 2*pi, 100 )        # useful to evaluate function at lots of points
>>> f = sin(x)
\end{verbatim}
% See also
% array, zeros, zeros_like, ones, ones_like, empty, empty_like, arange, linspace, rand, randn, fromfunction, fromfile
\newpage

%-----------------------------------------------------------------------------%
%Numpy Section 5
\subsection{Printing Arrays}
When you print an array, NumPy displays it in a similar way to nested lists, but with the following layout:
the last axis is printed from left to right,
the second-to-last is printed from top to bottom,
the rest are also printed from top to bottom, with each slice separated from the next by an empty line.
One-dimensional arrays are then printed as rows, bidimensionals as matrices and tridimensionals as lists of matrices.
\begin{verbatim}
>>> a = arange(6)                         # 1d array
>>> print a
[0 1 2 3 4 5]
>>>
>>> b = arange(12).reshape(4,3)           # 2d array
>>> print b
[[ 0  1  2]
 [ 3  4  5]
 [ 6  7  8]
 [ 9 10 11]]
>>>
>>> c = arange(24).reshape(2,3,4)         # 3d array
>>> print c
[[[ 0  1  2  3]
  [ 4  5  6  7]
  [ 8  9 10 11]]

 [[12 13 14 15]
  [16 17 18 19]
  [20 21 22 23]]]
\end{verbatim}

%-----------------------------------------------------------------------------%
See below to get more details on reshape.
If an array is too large to be printed, NumPy automatically skips the central part of the array and only prints the corners:
\begin{verbatim}
>>> print arange(10000)
[   0    1    2 ..., 9997 9998 9999]
>>>
>>> print arange(10000).reshape(100,100)
[[   0    1    2 ...,   97   98   99]
 [ 100  101  102 ...,  197  198  199]
 [ 200  201  202 ...,  297  298  299]
 ...,
 [9700 9701 9702 ..., 9797 9798 9799]
 [9800 9801 9802 ..., 9897 9898 9899]
 [9900 9901 9902 ..., 9997 9998 9999]]
\end{verbatim}
%-----------------------------------------------------------------------------%
To disable this behaviour and force NumPy to print the entire array, you can change the printing options using \textbf{\textit{set printoptions}}.
\begin{verbatim}
>>> set_printoptions(threshold='nan')
\end{verbatim}
%Numpy Section 6
\subsection{Basic Operations}
Arithmetic operators on arrays apply elementwise. A new array is created and filled with the result.
\begin{verbatim}
>>> a = array( [20,30,40,50] )
>>> b = arange( 4 )
>>> b
array([0, 1, 2, 3])
>>> c = a-b
>>> c
array([20, 29, 38, 47])
>>> b**2
array([0, 1, 4, 9])
>>> 10*sin(a)
array([ 9.12945251, -9.88031624,  7.4511316 , -2.62374854])
>>> a<35
array([True, True, False, False], dtype=bool)
\end{verbatim}
Unlike in many matrix languages, the product operator * operates elementwise in NumPy arrays. The matrix product can be performed using the dot function or creating matrix objects ( see matrix section of this tutorial ).
\begin{verbatim}
>>> A = array( [[1,1],
...             [0,1]] )
>>> B = array( [[2,0],
...             [3,4]] )
>>> A*B                         # elementwise product
array([[2, 0],
       [0, 4]])
>>> dot(A,B)                    # matrix product
array([[5, 4],
       [3, 4]])
\end{verbatim}
%-----------------------------------------------------------------------------%
Some operations, such as $+=$ and $\ast =$, act in place to modify an existing array rather than create a new one.
\begin{verbatim}
>>> a = ones((2,3), dtype=int)
>>> b = random.random((2,3))
>>> a *= 3
>>> a
array([[3, 3, 3],
       [3, 3, 3]])
>>> b += a
>>> b
array([[ 3.69092703,  3.8324276 ,  3.0114541 ],
       [ 3.18679111,  3.3039349 ,  3.37600289]])
>>> a += b                                  # b is converted to integer type
>>> a
array([[6, 6, 6],
       [6, 6, 6]])
\end{verbatim}
%-----------------------------------------------------------------------------%
When operating with arrays of different types, the type of the resulting array corresponds to the more general or precise one (a behavior known as upcasting).
\begin{verbatim}
>>> a = ones(3, dtype=int32)
>>> b = linspace(0,pi,3)
>>> b.dtype.name
'float64'
>>> c = a+b
>>> c
array([ 1.        ,  2.57079633,  4.14159265])
>>> c.dtype.name
'float64'
>>> d = exp(c*1j)
>>> d
array([ 0.54030231+0.84147098j, -0.84147098+0.54030231j,
       -0.54030231-0.84147098j])
>>> d.dtype.name
'complex128'
\end{verbatim}

Many unary operations, such as computing the sum of all the elements in the array, are implemented as methods of the ndarray class.
\begin{verbatim}
>>> a = random.random((2,3))
>>> a
array([[ 0.6903007 ,  0.39168346,  0.16524769],
       [ 0.48819875,  0.77188505,  0.94792155]])
>>> a.sum()
3.4552372100521485
>>> a.min()
0.16524768654743593
>>> a.max()
0.9479215542670073
\end{verbatim}
%-----------------------------------------------------------------------------%
By default, these operations apply to the array as though it were a list of numbers, regardless of its shape. However, by specifying the axis parameter you can apply an operation along the specified axis of an array:
\begin{verbatim}
>>> b = arange(12).reshape(3,4)
>>> b
array([[ 0,  1,  2,  3],
       [ 4,  5,  6,  7],
       [ 8,  9, 10, 11]])
>>>
>>> b.sum(axis=0)                            # sum of each column
array([12, 15, 18, 21])
>>>
>>> b.min(axis=1)                            # min of each row
array([0, 4, 8])
>>>
>>> b.cumsum(axis=1)                         # cumulative sum along each row
array([[ 0,  1,  3,  6],
       [ 4,  9, 15, 22],
       [ 8, 17, 27, 38]])
\end{verbatim}
%--------------------------------------------------------------------------------------------%
\subsubsection{Universal Functions}
NumPy provides familiar mathematical functions such as sin, cos, and exp. In NumPy, these are called \textbf{\textit{universal functions}} (ufunc). Within NumPy, these functions operate elementwise on an array, producing an array as output.
\begin{verbatim}
>>> B = arange(3)
>>> B
array([0, 1, 2])
>>> exp(B)
array([ 1.        ,  2.71828183,  7.3890561 ])
>>> sqrt(B)
array([ 0.        ,  1.        ,  1.41421356])
>>> C = array([2., -1., 4.])
>>> add(B, C)
array([ 2.,  0.,  6.])
\end{verbatim}


%-------------------------------------------------------------------------------%
\textbf{See also}\newline
all, alltrue, any, apply along axis, argmax, argmin, argsort, average, bincount, ceil, clip, conj, conjugate, corrcoef, cov, cross, cumprod, cumsum, diff, dot, floor, inner, inv, lexsort, max, maximum, mean, median, min, minimum, nonzero, outer, prod, re, round, sometrue, sort, std, sum, trace, transpose, var, vdot, vectorize, where
%------------------------------------------------------------------------------%
% 13 June 2013 Page 23
% NumPy Section 7


\subsection{Indexing, Slicing and Iterating}
One-dimensional arrays can be indexed, sliced and iterated over, much like lists and other Python sequences.
\begin{verbatim}
>>> a = arange(10)**3
>>> a
array([  0,   1,   8,  27,  64, 125, 216, 343, 512, 729])
>>> a[2]
8
>>> a[2:5]
array([ 8, 27, 64])
>>> a[:6:2] = -1000    # equivalent to a[0:6:2] = -1000; from start to position 6, exclusive, set every 2nd element to -1000
>>> a
array([-1000,     1, -1000,    27, -1000,   125,   216,   343,   512,   729])
>>> a[ : :-1]                                 # reversed a
array([  729,   512,   343,   216,   125, -1000,    27, -1000,     1, -1000])
>>> for i in a:
...         print i**(1/3.),
...
nan 1.0 nan 3.0 nan 5.0 6.0 7.0 8.0 9.0
\end{verbatim}


Multidimensional arrays can have one index per axis. These indices are given in a tuple separated by commas:
\begin{verbatim}
>>> def f(x,y):
...         return 10*x+y
...
>>> b = fromfunction(f,(5,4),dtype=int)
>>> b
array([[ 0,  1,  2,  3],
       [10, 11, 12, 13],
       [20, 21, 22, 23],
       [30, 31, 32, 33],
       [40, 41, 42, 43]])
>>> b[2,3]
23
>>> b[0:5, 1]                       # each row in the second column of b
array([ 1, 11, 21, 31, 41])
>>> b[ : ,1]                        # equivalent to the previous example
array([ 1, 11, 21, 31, 41])
>>> b[1:3, : ]                      # each column in the second and third row of b
array([[10, 11, 12, 13],
       [20, 21, 22, 23]])
\end{verbatim}
%------------------------------------------------------------------------------%
% 13 June 2013  - 24 pages here

When fewer indices are provided than the number of axes, the missing indices are considered complete slices:


\begin{verbatim}
>>> b[-1]                                  # the last row. Equivalent to b[-1,:]
array([40, 41, 42, 43])
\end{verbatim}



The expression within brackets in b[i] is treated as an i followed by as many instances of : as needed to represent the remaining axes. 
%NumPy also allows you to write this using dots as b[i,...].
%The dots (...) represent as many colons as needed to produce a complete indexing tuple. For example, if x is a rank 5 array (i.e., it has 5 axes), then
%x[1,2,...] is equivalent to x[1,2,:,:,:],
%x[...,3] to x[:,:,:,:,3] and
%x[4,...,5,:] to x[4,:,:,5,:].
\begin{verbatim}
>>> c = array( [ [[  0,  1,  2],               # a 3D array (two stacked 2D arrays)
...               [ 10, 12, 13]],
...
...              [[100,101,102],
...               [110,112,113]] ] )
>>> c.shape
(2, 2, 3)
>>> c[1,...]                                   # same as c[1,:,:] or c[1]
array([[100, 101, 102],
       [110, 112, 113]])
>>> c[...,2]                                   # same as c[:,:,2]
array([[  2,  13],
       [102, 113]])
\end{verbatim}

Iterating over multidimensional arrays is done with respect to the first axis:
\begin{verbatim}
>>> for row in b:
...         print row
...
[0 1 2 3]
[10 11 12 13]
[20 21 22 23]
[30 31 32 33]
[40 41 42 43]
\end{verbatim}

%-----------------------------------------------------------------------------%
However, if one wants to perform an operation on each element in the array, one can use the flat attribute which is an iterator over all the elements of the array:
\begin{verbatim}
>>> for element in b.flat:
...         print element,
...
0 1 2 3 10 11 12 13 20 21 22 23 30 31 32 33 40 41 42 43
\end{verbatim}
See also
newaxis, ndenumerate, indices, index exp
%-----------------------------------------------------------------------------%
\subsection{Shape Manipulation}
Changing the shape of an array
An array has a shape given by the number of elements along each axis:
\begin{verbatim}
>>> a = floor(10*random.random((3,4)))
>>> a
array([[ 7.,  5.,  9.,  3.],
       [ 7.,  2.,  7.,  8.],
       [ 6.,  8.,  3.,  2.]])
>>> a.shape
(3, 4)
\end{verbatim}
The shape of an array can be changed with various commands:
\begin{verbatim}
>>> a.ravel() # flatten the array
array([ 7.,  5.,  9.,  3.,  7.,  2.,  7.,  8.,  6.,  8.,  3.,  2.])
>>> a.shape = (6, 2)
>>> a.transpose()
array([[ 7.,  9.,  7.,  7.,  6.,  3.],
       [ 5.,  3.,  2.,  8.,  8.,  2.]])
\end{verbatim}
The order of the elements in the array resulting from ravel() is normally "C-style", that is, the rightmost index "changes the fastest", so the element after a[0,0] is a[0,1]. If the array is reshaped to some other shape, again the array is treated as "C-style". Numpy normally creates arrays stored in this order, so \texttt{ravel()} will usually not need to copy its argument, but if the array was made by taking slices of another array or created with unusual options, it may need to be copied. The functions \texttt{ravel()} and reshape() can also be instructed, using an optional argument, to use FORTRAN-style arrays, in which the leftmost index changes the fastest.
\newpage
%-------------------------------------------------------------------------------%
The reshape function returns its argument with a modified shape, whereas the resize method modifies the array itself:
\begin{verbatim}
>>> a
array([[ 7.,  5.],
       [ 9.,  3.],
       [ 7.,  2.],
       [ 7.,  8.],
       [ 6.,  8.],
       [ 3.,  2.]])
>>> a.resize((2,6))
>>> a
array([[ 7.,  5.,  9.,  3.,  7.,  2.],
       [ 7.,  8.,  6.,  8.,  3.,  2.]])
\end{verbatim}
If a dimension is given as -1 in a reshaping operation, the other dimensions are automatically calculated:
\begin{verbatim}
>>> a.reshape(3,-1)
array([[ 7.,  5.,  9.,  3.],
       [ 7.,  2.,  7.,  8.],
       [ 6.,  8.,  3.,  2.]])
\end{verbatim}
See also:: shape example, reshape example, resize example, ravel example
%NumPy Section 


\subsection{Stacking together different arrays}

Several arrays can be stacked together along different axes:
\begin{verbatim}
>>> a = floor(10*random.random((2,2)))
>>> a
array([[ 1.,  1.],
       [ 5.,  8.]])
>>> b = floor(10*random.random((2,2)))
>>> b
array([[ 3.,  3.],
       [ 6.,  0.]])
>>> vstack((a,b))
array([[ 1.,  1.],
       [ 5.,  8.],
       [ 3.,  3.],
       [ 6.,  0.]])
>>> hstack((a,b))
array([[ 1.,  1.,  3.,  3.],
       [ 5.,  8.,  6.,  0.]])
\end{verbatim}
The function column stack stacks 1D arrays as columns into a 2D array. It is equivalent to vstack only for 1D arrays:

%------------------------------------------------------------------------------%
\begin{verbatim}
>>> column_stack((a,b))   # With 2D arrays
array([[ 1.,  1.,  3.,  3.],
       [ 5.,  8.,  6.,  0.]])
>>> a=array([4.,2.])
>>> b=array([2.,8.])
>>> a[:,newaxis]  # This allows to have a 2D columns vector
array([[ 4.],
       [ 2.]])
>>> column_stack((a[:,newaxis],b[:,newaxis]))
array([[ 4.,  2.],
       [ 2.,  8.]])
>>> vstack((a[:,newaxis],b[:,newaxis])) # The behavior of vstack is different
array([[ 4.],
       [ 2.],
       [ 2.],
       [ 8.]])
\end{verbatim}
%------------------------------------------------------------------------------%


The function row stack, on the other hand, stacks 1D arrays as rows into a 2D array.
For arrays of with more than two dimensions, hstack stacks along their second axes, vstack stacks along their first axes, and concatenate allows for an optional arguments giving the number of the axis along which the concatenation should happen.
Note
%In complex cases, r_[] and c_[] are useful for creating arrays by stacking numbers along one axis. They allow the use of range literals (":") :
\begin{verbatim}
>>> r_[1:4,0,4]
array([1, 2, 3, 0, 4])
\end{verbatim}

%When used with arrays as arguments, r_[] and c_[] are similar to vstack and hstack in their default behavior, but allow for an optional argument giving the number of the axis along which to concatenate.
%See also: hstack example, vstack exammple, column_stack example, row_stack example, concatenate example, c_ example, r_ example
\subsection{Splitting one array into several smaller ones}
Using hsplit, you can split an array along its horizontal axis, either by specifying the number of equally shaped arrays to return, or by specifying the columns after which the division should occur:
\begin{verbatim}
>>> a = floor(10*random.random((2,12)))
>>> a
array([[ 8.,  8.,  3.,  9.,  0.,  4.,  3.,  0.,  0.,  6.,  4.,  4.],
       [ 0.,  3.,  2.,  9.,  6.,  0.,  4.,  5.,  7.,  5.,  1.,  4.]])
>>> hsplit(a,3)   # Split a into 3
[array([[ 8.,  8.,  3.,  9.],
       [ 0.,  3.,  2.,  9.]]), array([[ 0.,  4.,  3.,  0.],
       [ 6.,  0.,  4.,  5.]]), array([[ 0.,  6.,  4.,  4.],
       [ 7.,  5.,  1.,  4.]])]
>>> hsplit(a,(3,4))   # Split a after the third and the fourth column
[array([[ 8.,  8.,  3.],
       [ 0.,  3.,  2.]]), array([[ 9.],
       [ 9.]]), array([[ 0.,  4.,  3.,  0.,  0.,  6.,  4.,  4.],
       [ 6.,  0.,  4.,  5.,  7.,  5.,  1.,  4.]])]
\end{verbatim}

vsplit splits along the vertical axis, and array split allows one to specify along which axis to split.

% 13 June 2013 Page 27

\subsubsection{Copies and Views}
When operating and manipulating arrays, their data is sometimes copied into a new array and sometimes not. This is often a source of confusion for beginners. There are three cases:
No Copy at All
Simple assignments make no copy of array objects or of their data.
\begin{verbatim}
>>> a = arange(12)
>>> b = a            # no new object is created
>>> b is a           # a and b are two names for the same ndarray object
True
>>> b.shape = 3,4    # changes the shape of a

>>> a.shape
(3, 4)
\end{verbatim}

Python passes mutable objects as references, so function calls make no copy.
\begin{verbatim}
>>> def f(x):
...     print id(x)
...
>>> id(a)                           # id is a unique identifier of an object
148293216
>>> f(a)
148293216
\end{verbatim}
%NumPy Section
\newpage
\subsection{View or Shallow Copy}
Different array objects can share the same data. The view method creates a new array object that looks at the same data.
\begin{verbatim}
>>> c = a.view()
>>> c is a
False
>>> c.base is a                        # c is a view of the data owned by a
True
>>> c.flags.owndata
False
>>>
>>> c.shape = 2,6                      # a's shape doesn't change
>>> a.shape
(3, 4)
>>> c[0,4] = 1234                      # a's data changes
>>> a
array([[   0,    1,    2,    3],
       [1234,    5,    6,    7],
       [   8,    9,   10,   11]])
\end{verbatim}
% 13 June 2013 Page 29


Slicing an array returns a view of it:
\begin{verbatim}
>>> s = a[ : , 1:3]     # spaces added for clarity; could also be written "s = a[:,1:3]"
>>> s[:] = 10           # s[:] is a view of s. Note the difference between s=10 and s[:]=10
>>> a
array([[   0,   10,   10,    3],
       [1234,   10,   10,    7],
       [   8,   10,   10,   11]])
\end{verbatim}

%-------------------------------------------------------------------------------------------------%
% NumPy Section 
\subsection{Deep Copy}
The copy method makes a complete copy of the array and its data.
\begin{verbatim}
>>> d = a.copy()                          # a new array object with new data is created
>>> d is a
False
>>> d.base is a                           # d doesn't share anything with a
False
>>> d[0,0] = 9999
>>> a
array([[   0,   10,   10,    3],
       [1234,   10,   10,    7],
       [   8,   10,   10,   11]])
\end{verbatim}
\subsubsection{Functions and Methods Overview}
Here is a list of NumPy functions and methods names ordered in some categories. The names link to the Numpy Example List so that you can see the functions in action.
\subsubsection{Array Creation}
arange, array, copy, empty, empty like, eye, fromfile, fromfunction, identity, linspace, logspace, mgrid, ogrid, ones, ones like, r , zeros, zeros like
\subsubsection{Conversions}
astype, atleast 1d, atleast 2d, atleast 3d, mat
\subsubsection{Manipulations}
array split, column stack, concatenate, diagonal, dsplit, dstack, hsplit, hstack, item, newaxis, ravel, repeat, reshape, resize, squeeze, swapaxes, take, transpose, vsplit, vstack

\begin{description}
\item[Questions]
all, any, nonzero, where
\item[Ordering]
argmax, argmin, argsort, max, min, ptp, searchsorted, sort
\item[Operations]
choose, compress, cumprod, cumsum, inner, fill, imag, prod, put, putmask, real, sum
\item[Basic Statistics]
cov, mean, std, var
\item[Basic Linear Algebra]
cross, dot, outer, svd, vdot
%Less Basic
\end{description}

%13 June 2013  Page 31

\subsection{Broadcasting rules}
Broadcasting allows universal functions to deal in a meaningful way with inputs that do not have exactly the same shape.
The first rule of broadcasting is that if all input arrays do not have the same number of dimensions, a "1" will be repeatedly prepended to the shapes of the smaller arrays until all the arrays have the same number of dimensions.
The second rule of broadcasting ensures that arrays with a size of 1 along a particular dimension act as if they had the size of the array with the largest shape along that dimension. The value of the array element is assumed to be the same along that dimension for the "broadcast" array.
After application of the broadcasting rules, the sizes of all arrays must match. More details can be found in this documentation.
Fancy indexing and index tricks
NumPy offers more indexing facilities than regular Python sequences. In addition to indexing by integers and slices, as we saw before, arrays can be indexed by arrays of integers and arrays of booleans.
Indexing with Arrays of Indices
\begin{verbatim}
>>> a = arange(12)**2                          # the first 12 square numbers
>>> i = array( [ 1,1,3,8,5 ] )                 # an array of indices
>>> a[i]                                       # the elements of a at the positions i
array([ 1,  1,  9, 64, 25])
>>>
>>> j = array( [ [ 3, 4], [ 9, 7 ] ] )         # a bidimensional array of indices
>>> a[j]                                       # the same shape as j
array([[ 9, 16],
       [81, 49]])
\end{verbatim}
When the indexed array a is multidimensional, a single array of indices refers to the first dimension of a. The following example shows this behavior by converting an image of labels into a color image using a palette.
\begin{verbatim}
>>> palette = array( [ [0,0,0],                # black
...                    [255,0,0],              # red
...                    [0,255,0],              # green
...                    [0,0,255],              # blue
...                    [255,255,255] ] )       # white
>>> image = array( [ [ 0, 1, 2, 0 ],           # each value corresponds to a color in the palette
...                  [ 0, 3, 4, 0 ]  ] )
>>> palette[image]                            # the (2,4,3) color image
array([[[  0,   0,   0],
        [255,   0,   0],
        [  0, 255,   0],
        [  0,   0,   0]],
       [[  0,   0,   0],
        [  0,   0, 255],
        [255, 255, 255],
        [  0,   0,   0]]])
\end{verbatim}
%-----------------------------%
We can also give indexes for more than one dimension. The arrays of indices for each dimension must have the same shape.
\begin{verbatim}
>>> a = arange(12).reshape(3,4)
>>> a
array([[ 0,  1,  2,  3],
       [ 4,  5,  6,  7],
       [ 8,  9, 10, 11]])
>>> i = array( [ [0,1],                        # indices for the first dim of a
...              [1,2] ] )
>>> j = array( [ [2,1],                        # indices for the second dim
...              [3,3] ] )
>>>
>>> a[i,j]                                     # i and j must have equal shape
array([[ 2,  5],
       [ 7, 11]])
>>>
>>> a[i,2]
array([[ 2,  6],
       [ 6, 10]])
>>>
>>> a[:,j]                                     # i.e., a[ : , j]
array([[[ 2,  1],
        [ 3,  3]],
       [[ 6,  5],
        [ 7,  7]],
       [[10,  9],
        [11, 11]]])
\end{verbatim}

Naturally, we can put i and j in a sequence (say a list) and then do the indexing with the list.
\begin{verbatim}
>>> l = [i,j]
>>> a[l]                                       # equivalent to a[i,j]
array([[ 2,  5],
       [ 7, 11]])
\end{verbatim}
However, we can not do this by putting i and j into an array, because this array will be interpreted as indexing the first dimension of a.
\begin{verbatim}
>>> s = array( [i,j] )
>>> a[s]                                       # not what we want
\end{verbatim}
%------------------------------------%
Traceback (most recent call last):
\begin{verbatim}
  File "<stdin>", line 1, in ?
IndexError: index (3) out of range (0<=index<=2) in dimension 0
>>>
>>> a[tuple(s)]                             
   # same as a[i,j]
array([[ 2,  5],
       [ 7, 11]])
\end{verbatim}
Another common use of indexing with arrays is the search of the maximum value of time-dependent series :
\begin{verbatim}
>>> time = linspace(20, 145, 5)                 # time scale
>>> data = sin(arange(20)).reshape(5,4)         # 4 time-dependent series
>>> time
array([  20.  ,   51.25,   82.5 ,  113.75,  145.  ])
>>> data
array([[ 0.        ,  0.84147098,  0.90929743,  0.14112001],
       [-0.7568025 , -0.95892427, -0.2794155 ,  0.6569866 ],
       [ 0.98935825,  0.41211849, -0.54402111, -0.99999021],
       [-0.53657292,  0.42016704,  0.99060736,  0.65028784],
       [-0.28790332, -0.96139749, -0.75098725,  0.14987721]])
>>>
>>> ind = data.argmax(axis=0)                   # index of the maxima for each series
>>> ind
array([2, 0, 3, 1])
>>>
>>> time_max = time[ ind]                       # times corresponding to the maxima
>>>
>>> data_max = data[ind, xrange(data.shape[1])] # => data[ind[0],0], data[ind[1],1]...
>>>
>>> time_max
array([  82.5 ,   20.  ,  113.75,   51.25])
>>> data_max
array([ 0.98935825,  0.84147098,  0.99060736,  0.6569866 ])
>>>
>>> all(data_max == data.max(axis=0))
True
\end{verbatim}

You can also use indexing with arrays as a target to assign to:
\begin{verbatim}
>>> a = arange(5)
>>> a
array([0, 1, 2, 3, 4])
>>> a[[1,3,4]] = 0
>>> a
array([0, 0, 2, 0, 0])
\end{verbatim}

However, when the list of indices contains repetitions, the assignment is done several times, leaving behind the last value:
\begin{verbatim}
>>> a = arange(5)
>>> a[[0,0,2]]=[1,2,3]
>>> a
array([2, 1, 3, 3, 4])
\end{verbatim}
This is reasonable enough, but watch out if you want to use Python's += construct, as it may not do what you expect:
\begin{verbatim}
>>> a = arange(5)
>>> a[[0,0,2]]+=1
>>> a
array([1, 1, 3, 3, 4])
\end{verbatim}

Even though 0 occurs twice in the list of indices, the 0th element is only incremented once. This is because Python requires "a+=1" to be equivalent to "a=a+1".
\subsection{Indexing with Boolean Arrays}
When we index arrays with arrays of (integer) indices we are providing the list of indices to pick. With boolean indices the approach is different; we explicitly choose which items in the array we want and which ones we don't.
The most natural way one can think of for boolean indexing is to use boolean arrays that have the same shape as the original array:
\begin{verbatim}
>>> a = arange(12).reshape(3,4)
>>> b = a > 4
>>> b                                          # b is a boolean with a's shape
array([[False, False, False, False],
       [False, True, True, True],
       [True, True, True, True]], dtype=bool)
>>> a[b]                                       # 1d array with the selected elements
array([ 5,  6,  7,  8,  9, 10, 11])
\end{verbatim}
This property can be very useful in assignments:
\begin{verbatim}
>>> a[b] = 0                                   # All elements of 'a' higher than 4 become 0
>>> a
array([[0, 1, 2, 3],
       [4, 0, 0, 0],
       [0, 0, 0, 0]])
\end{verbatim}
You can look at the Mandelbrot set example to see how to use boolean indexing to generate an image of the Mandelbrot set.
The second way of indexing with booleans is more similar to integer indexing; for each dimension of the array we give a 1D boolean array selecting the slices we want.
\begin{verbatim}
>>> a = arange(12).reshape(3,4)
>>> b1 = array([False,True,True])             # first dim selection
>>> b2 = array([True,False,True,False])       # second dim selection
>>>
>>> a[b1,:]                                   # selecting rows
array([[ 4,  5,  6,  7],
       [ 8,  9, 10, 11]])
>>>
>>> a[b1]                                     # same thing
array([[ 4,  5,  6,  7],
       [ 8,  9, 10, 11]])
>>>
>>> a[:,b2]                                   # selecting columns
array([[ 0,  2],
       [ 4,  6],
       [ 8, 10]])
>>>
>>> a[b1,b2]                                  # a weird thing to do
array([ 4, 10])
\end{verbatim}
% 13 June 2013  Page 35


Note that the length of the 1D boolean array must coincide with the length of the dimension (or axis) you want to slice. In the previous example, b1 is a 1-rank array with length 3 (the number of rows in a), and b2 (of length 4) is suitable to index the 2nd rank (columns) of a.



\subsection{The ix function}
%The ix_() function
The ix function can be used to combine different vectors so as to obtain the result for each n-uplet. For example, if you want to compute all the $a+b*c$ for all the triplets taken from each of the vectors a, b and c:
\begin{verbatim}
>>> a = array([2,3,4,5])
>>> b = array([8,5,4])
>>> c = array([5,4,6,8,3])
>>> ax,bx,cx = ix_(a,b,c)
>>> ax
array([[[2]],

       [[3]],

       [[4]],

       [[5]]])
>>> bx
array([[[8],
        [5],
        [4]]])
>>> cx
array([[[5, 4, 6, 8, 3]]])
>>> ax.shape, bx.shape, cx.shape
((4, 1, 1), (1, 3, 1), (1, 1, 5))
>>> result = ax+bx*cx
>>> result
array([[[42, 34, 50, 66, 26],
        [27, 22, 32, 42, 17],
        [22, 18, 26, 34, 14]],
       [[43, 35, 51, 67, 27],
        [28, 23, 33, 43, 18],
        [23, 19, 27, 35, 15]],
       [[44, 36, 52, 68, 28],
        [29, 24, 34, 44, 19],
        [24, 20, 28, 36, 16]],
       [[45, 37, 53, 69, 29],
        [30, 25, 35, 45, 20],
        [25, 21, 29, 37, 17]]])
>>> result[3,2,4]
17
>>> a[3]+b[2]*c[4]
17
\end{verbatim}
%------------------------------------------------------------------%
You could also implement the reduce as follows:
\begin{verbatim}
def ufunc_reduce(ufct, *vectors):
    vs = ix_(*vectors)
    r = ufct.identity
    for v in vs:
        r = ufct(r,v)
    return r
\end{verbatim}
and then use it as:
\begin{verbatim}
>>> ufunc_reduce(add,a,b,c)
array([[[15, 14, 16, 18, 13],
        [12, 11, 13, 15, 10],
        [11, 10, 12, 14,  9]],
       [[16, 15, 17, 19, 14],
        [13, 12, 14, 16, 11],
        [12, 11, 13, 15, 10]],
       [[17, 16, 18, 20, 15],
        [14, 13, 15, 17, 12],
        [13, 12, 14, 16, 11]],
       [[18, 17, 19, 21, 16],
        [15, 14, 16, 18, 13],
        [14, 13, 15, 17, 12]]])
\end{verbatim}
The advantage of this version of reduce compared to the normal ufunc.reduce is that it makes use of the Broadcasting Rules in order to avoid creating an argument array the size of the output times the number of vectors.
Indexing with strings (See RecordArrays)
% 13 June 2013 Page 37
%--------------------------------------------------------------------------------------------------------------------------------------%
\end{document}

\subsection{ Linear Algebra }
Work in progress. Basic linear algebra to be included here.

\subsection{Simple Array Operations}
See linalg.py in numpy folder for more.
\begin{verbatim}
>>> from numpy import *
>>> from numpy.linalg import *

>>> a = array([[1.0, 2.0], [3.0, 4.0]])
>>> print a
[[ 1.  2.]
 [ 3.  4.]]

>>> a.transpose()
array([[ 1.,  3.],
       [ 2.,  4.]])

>>> inv(a)
array([[-2. ,  1. ],
       [ 1.5, -0.5]])

>>> u = eye(2) # unit 2x2 matrix; "eye" represents "I"
>>> u
array([[ 1.,  0.],
       [ 0.,  1.]])
>>> j = array([[0.0, -1.0], [1.0, 0.0]])

>>> dot (j, j) # matrix product
array([[-1.,  0.],
       [ 0., -1.]])

>>> trace(u)  # trace
2.0

>>> y = array([[5.], [7.]])
>>> solve(a, y)
array([[-3.],
       [ 4.]])

>>> eig(j)
(array([ 0.+1.j,  0.-1.j]),
array([[ 0.70710678+0.j,  0.70710678+0.j],
       [ 0.00000000-0.70710678j,  0.00000000+0.70710678j]]))
\end{verbatim}
%Page 38
%--------------------------------------------------------------------------------------------------%
\begin{verbatim}
Parameters:
    square matrix

Returns
    The eigenvalues, each repeated according to its multiplicity.

    The normalized (unit "length") eigenvectors, such that the
    column ``v[:,i]`` is the eigenvector corresponding to the
    eigenvalue ``w[i]`` .
\end{verbatim}

\end{document}
\subsubsection{The Matrix Class}
Here is a short intro to the Matrix class.
\begin{verbatim}
>>> A = matrix('1.0 2.0; 3.0 4.0')
>>> A
[[ 1.  2.]
 [ 3.  4.]]
>>> type(A)  # file where class is defined
<class 'numpy.matrixlib.defmatrix.matrix'>

>>> A.T  # transpose
[[ 1.  3.]
 [ 2.  4.]]
\end{verbatim}

\end{document}

\begin{verbatim}
>>> X = matrix('5.0 7.0')
>>> Y = X.T
>>> Y
[[5.]
 [7.]]

>>> print A*Y  # matrix multiplication
[[19.]
 [43.]]

>>> print A.I  # inverse
[[-2.   1. ]
 [ 1.5 -0.5]]

>>> solve(A, Y)  # solving linear equation
matrix([[-3.],
        [ 4.]])
\end{verbatim}
\subsection{Indexing: Comparing Matrices and 2D Arrays}
Note that there are some important differences between NumPy arrays and matrices. NumPy provides two fundamental objects: an N-dimensional array object and a universal function object. Other objects are built on top of these. In particular, matrices are 2-dimensional array objects that inherit from the NumPy array object. For both arrays and matrices, indices must consist of a proper combination of one or more of the following: integer scalars, ellipses, a list of integers or boolean values, a tuple of integers or boolean values, and a 1-dimensional array of integer or boolean values. A matrix can be used as an index for matrices, but commonly an array, list, or other form is needed to accomplish a given task.


%-----------------------------------------------------------------------------------------------%
As usual in Python, indexing is zero-based. Traditionally we represent a 2D array or matrix as a rectangular array of rows and columns, where movement along axis 0 is movement across rows, while movement along axis 1 is movement across columns.
Let's make an array and matrix to slice:
\begin{verbatim}
>>> A = arange(12)
>>> A
array([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11])
>>> A.shape = (3,4)
>>> M = mat(A.copy())
>>> print type(A),"  ",type(M)
<type 'numpy.ndarray'>    <class 'numpy.core.defmatrix.matrix'>
>>> print A
[[ 0  1  2  3]
 [ 4  5  6  7]
 [ 8  9 10 11]]
>>> print M
[[ 0  1  2  3]
 [ 4  5  6  7]
 [ 8  9 10 11]]
\end{verbatim}
\end{document}

%-----------------------------------------------------------------------------------------------%
Now, let's take some simple slices. Basic slicing uses slice objects or integers. For example, the evaluation of A[:] and M[:] will appear familiar from Python indexing, however it is important to note that slicing NumPy arrays does *not* make a copy of the data; slicing provides a new view of the same data.
>>> print A[:]; print A[:].shape
[[ 0  1  2  3]
 [ 4  5  6  7]
 [ 8  9 10 11]]
(3, 4)
>>> print M[:]; print M[:].shape
[[ 0  1  2  3]
 [ 4  5  6  7]
 [ 8  9 10 11]]
(3, 4)
Now for something that differs from Python indexing: you may use comma-separated indices to index along multiple axes at the same time.
>>> print A[:,1]; print A[:,1].shape
[1 5 9]
(3,)
>>> print M[:,1]; print M[:,1].shape
[[1]
 [5]
 [9]]
(3, 1)
Notice the difference in the last two results. Use of a single colon for the 2D array produces a 1-dimensional array, while for a matrix it produces a 2-dimensional matrix. A slice of a matrix will always produce a matrix. For example, a slice M[2,:] produces a matrix of shape (1,4). In contrast, a slice of an array will always produce an array of the lowest possible dimension. For example, if C were a 3-dimensional array, C[...,1] produces a 2D array while C[1,:,1] produces a 1-dimensional array. From this point on, we will show results only for the array slice if the results for the corresponding matrix slice are identical.
Lets say that we wanted the 1st and 3rd column of an array. One way is to slice using a list:
>>> A[:,[1,3]]
array([[ 1,  3],
       [ 5,  7],
       [ 9, 11]])
A slightly more complicated way is to use the take() method:
>>> A[:,].take([1,3],axis=1)
array([[ 1,  3],
       [ 5,  7],
       [ 9, 11]])
If we wanted to skip the first row, we could use:
>>> A[1:,].take([1,3],axis=1)
array([[ 5,  7],
       [ 9, 11]])
Or we could simply use A[1:,[1,3]]. Yet another way to slice the above is to use a cross product:
>>> A[ix_((1,2),(1,3))]
array([[ 5,  7],
       [ 9, 11]])
For the reader's convenience, here is our array again:
\begin{verbatim}
>>> print A
[[ 0  1  2  3]
 [ 4  5  6  7]
 [ 8  9 10 11]]
\end{verbatim}

%-----------------------------------------------------------------------------------------------%
Now let's do something a bit more complicated. Lets say that we want to retain all columns where the first row is greater than 1. One way is to create a boolean index:
>>> A[0,:]>1
array([False, False, True, True], dtype=bool)
>>> A[:,A[0,:]>1]
array([[ 2,  3],
       [ 6,  7],
       [10, 11]])
Just what we wanted! But indexing the matrix is not so convenient.
>>> M[0,:]>1
matrix([[False, False, True, True]], dtype=bool)
>>> M[:,M[0,:]>1]
matrix([[2, 3]])
The problem of course is that slicing the matrix slice produced a matrix. But matrices have a convenient 'A' attribute whose value is the array representation, so we can just do this instead:
>>> M[:,M.A[0,:]>1]
matrix([[ 2,  3],
        [ 6,  7],
        [10, 11]])
If we wanted to conditionally slice the matrix in two directions, we must adjust our strategy slightly. Instead of
>>> A[A[:,0]>2,A[0,:]>1]
array([ 6, 11])
>>> M[M.A[:,0]>2,M.A[0,:]>1]
matrix([[ 6, 11]])
we need to use the cross product 'ix_':
>>> A[numpy.ix_(A[:,0]>2,A[0,:]>1)]
array([[ 6,  7],
       [10, 11]])
>>> M[numpy.ix_(M.A[:,0]>2,M.A[0,:]>1)]
matrix([[ 6,  7],
        [10, 11]])
Tricks and Tips
Here we give a list of short and useful tips.
"Automatic" Reshaping
To change the dimensions of an array, you can omit one of the sizes which will then be deduced automatically:
>>> a = arange(30)
>>> a.shape = 2,-1,3  # -1 means "whatever is needed"
>>> a.shape
(2, 5, 3)
>>> a
array([[[ 0,  1,  2],
        [ 3,  4,  5],
        [ 6,  7,  8],
        [ 9, 10, 11],
        [12, 13, 14]],
       [[15, 16, 17],
        [18, 19, 20],
        [21, 22, 23],
        [24, 25, 26],
        [27, 28, 29]]])
Vector Stacking
How do we construct a 2D array from a list of equally-sized row vectors? In MATLAB this is quite easy: if x and y are two vectors of the same length you only need do m=[x;y]. In NumPy this works via the functions column_stack, dstack, hstack and vstack, depending on the dimension in which the stacking is to be done. For example:
x = arange(0,10,2)                     # x=([0,2,4,6,8])
y = arange(5)                          # y=([0,1,2,3,4])
m = vstack([x,y])                      # m=([[0,2,4,6,8],
                                       #     [0,1,2,3,4]])
xy = hstack([x,y])                     # xy =([0,2,4,6,8,0,1,2,3,4])
The logic behind those functions in more than two dimensions can be strange.
See also NumPy for Matlab Users and add your new findings there.
Histograms
The NumPy histogram function applied to an array returns a pair of vectors: the histogram of the array and the vector of bins. Beware: matplotlib also has a function to build histograms (called hist, as in Matlab) that differs from the one in NumPy. The main difference is that pylab.hist plots the histogram automatically, while numpy.histogram only generates the data.
import numpy
import pylab
# Build a vector of 10000 normal deviates with variance 0.5^2 and mean 2
mu, sigma = 2, 0.5
v = numpy.random.normal(mu,sigma,10000)
# Plot a normalized histogram with 50 bins
pylab.hist(v, bins=50, normed=1)       # matplotlib version (plot)
pylab.show()
# Compute the histogram with numpy and then plot it
(n, bins) = numpy.histogram(v, bins=50, normed=True)  # NumPy version (no plot)
pylab.plot(.5*(bins[1:]+bins[:-1]), n)
pylab.show()

%-----------------------------------------------------------------------------%
%http://www.daimi.au.dk/~besen/TBiB2007/lecture-notes/rpy.html
\section{Rpy}

Python is a powerful programming language, but occasionally we need to solve problems that can more easily be solved in other, more specialised, programming languages.

For statistical analysis and data visualisation, the programming language R, is an excellent choice. But where R is a very strong language for mathematical (numerical) computation and statistics, it is rather cumbersome to perform typical scripting tasks with it.

Ideally, we would want to use Python for the scripting tasks and R for the statistical tasks. And for once, we can actually get the best of both worlds by combining the two languages.

Integrating Python and R is particularly simple due to the rpy module, that essentially embeds R as a module in Python.

In this lecture we will see a few examples of how to use RPy to communicate with R from Python. We will not go into many details, however, since R programming is outside the scope of this class, but after reading this lecture note, you should be able to use RPy after learning R programming.


\subsection{Rpy:Invoking RPy}

To use RPy all you need to do is to import the rpy module.

Well, theoretically...

RPy is not globally installed at DAIMI, so to use it, you need a local installation, and you then need to tell Python where it can be found.

There is a version of RPY installed at /users/compbio/Applications/R231py/rpy/lib/python/ and to inform Python of this, you need to set the PYTHONPATH environment variable.

$ export PYTHONPATH=/users/compbio/Applications/R231py/rpy/lib/python/:$PYTHONPATH
in BASH or

$ setenv PYTHONPATH /users/compbio/Applications/R231py/rpy/lib/python/:$PYTHONPATH
in TCSH.

After this, it is as simple as importing rpy.

import rpy
The communication with R is all through an object called r in this module, so for convenience we can just load that object into our namespace this way:

from rpy import r
and after this, we can talk to R through r.


\subsection{Rpy: Talking to R}

The r object essentially works like the R prompt if you run R directly. We can execute R code in two different ways using r: we can tread it as a function that takes R code as input:

>>> r('x <- c(1,2,3)')
[1.0, 2.0, 3.0]
>>> r('x')
[1.0, 2.0, 3.0]
>>> r('x*x')
[1.0, 4.0, 9.0]
or, when accessing functions or variables, just pretend that they are attributes of the r object:

>>> r('x <- c(1,2,3)')
[1.0, 2.0, 3.0]
>>> r.x
where the later is what we will typically use.

Don't confuse this way of accessing r with real attributes, though. There is magic happening behind the scene for this to work. So do not try to create R object by assigning to r attributes like this:

>>> r('x <- c(1,2,3)')
[1.0, 2.0, 3.0]
>>> r.x
[1.0, 2.0, 3.0]
>>> r.x = [3,2,1]
>>> r.x
[3, 2, 1]
>>> r('x')
[1.0, 2.0, 3.0]
You can access the variables in R through an attribute in r, but if you assign an attribute to r you overwrite the magic without assigning variables on the R side.

Just don't do it.

If you really need to assign a parameter on the R side of r  and mind you, mostly you should be able to just pass values over to R through function parameters  you can use the assign value:

>>> del r.x
>>> r.assign('x', range(1,6))
>>> r('x')
[1, 2, 3, 4, 5]
Here, the first line is necessary because the values are cached on the Python side, so updating the R side will not necessarily update the Python side. Whenever r.attribute differs from r(attribute), the first is what Python sees and the second what R sees. Delete the first to invalidate the cache, and the next access to the attribute will fetch the current value from R.


\subsection{Rpy: Python and R names}

Web-resources:
R objects look up.
The naming convention in Python and R  not to mention the set of legal names  differs. Therefore, there is some name changing going on when we look up R objects as attributes of r.

For example, where we in python would call a function t_test, the R convention would be to use . (dot) instead of _ (underscore) and therefore use t.test (something that wouldn't work in Python where dot has a different meaning).

Attribute lookup therefore performs name modification in addition to its other magic, and changes "_" to ".", "__" to "<-" and removes a final underscore if it is preceded by a letter. The last change is needed when you want to look up a name in R that is a reserved keyword in python, such as print.

If you really need to, you can also use r["name"] to look up "name", but this is usually only needed when accessing special character names in R, so we won't bother with it here.

\subsection{Rpy: R and graphics}

Web-resources:
Plotting with RPy.
But enough about technicalities, let us get a feeling for RPy by writing some actual code.

We start with plotting data. The R function for plotting simple x-y data is called \texttt{plot()}, so to call it from Python we use \texttt{r.plot()}.

\begin{framed}
\begin{verbatim}
from rpy import r

x = range(1,11)
y = [i**2 for i in x]
r.plot(x,y)
\end{verbatim}
\end{framed}

This just plots points at the x-y coordinates. The x and y label looks a bit strange, but this is because the function doesn't know what to call the variables. In R it would know the names of the variables (x and y), but through Python it doesn't. We can fix that, though, using the xlab and ylab parameters:
\begin{framed}
\begin{verbatim}
r.plot(x,y, xlab='x', ylab='y')
\end{verbatim}
\end{framed}

We can set a title on the plot using the main parameter:

\begin{framed}
\begin{verbatim}
r.plot(x,y, xlab='x', ylab='y', main='My first plot')
\end{verbatim}
\end{framed}

Colours we can set with the col parameter; the type of point with the pch parameter; and where applicable, we can set the background colour in the points with the bg option:

\begin{framed}
\begin{verbatim}
r.plot(x,y, xlab='x', ylab='y', main='My first plot',
       pch=21, col='blue', bg='lightblue')
\end{verbatim}
\end{framed}


We can change the type of plots between points, lines, or both using type with parameters "p" (points), "l" (lines), or "o"/"b" (both lines and points  the difference is in whether there should be white space around the points, "b", or not "o").

\begin{framed}
\begin{verbatim}
r.plot(x,y, xlab='x', ylab='y', main='My first plot',
       pch=21, col='blue', bg='lightblue', type='o')
\end{verbatim}
\end{framed}

\subsubsection{Exercise RPY.1} Plot a sine curve in red. You can use the math module to calculate sin(x).

If you use the plot() function this way, you only plot one set of x-y values. But you can extend a plot using e.g. the points() or lines() functions:

\begin{framed}
\begin{verbatim}
from rpy import r

x = range(1,11)
y = [i**2 for i in x]
z = [i**3 for i in x]
r.plot(x, y, main='My second plot', xlab='x', ylab='y', type='l', col='blue')
r.lines(x, z, col='red')
\end{verbatim}
\end{framed}


\subsubsection{Exercise RPY.2} 

Plot a sine curve in red and a cosine in blue.

When \texttt{plot()} is called, it calculates the right x and y range to fit the data on the plot. This is usually what we want, but if we add lines or points afterwards, there is a chance that they do not fit unto the plotting area. To change that, we can use the xlim or ylim parameters. A useful function in this setting is the range function that calculates the minimum and maximum value of a set:

\begin{verbatim}
from rpy import r

x = range(1,11)
y = [i**2 for i in x]
z = [i**3 for i in x]
r.plot(x, y, main='My second plot', xlab='x', ylab='y', type='l', col='blue',
       ylim=r.range(y,z))
r.lines(x, z, col='red')
\end{verbatim}

Another, very useful, graphics function is hist that simply plots histograms of data. You can specify most of the same graphical parameters as for \texttt{plot() } x and y label, main title, etc. but instead of x-y plots it draws a histogram from a set of values:
\begin{framed}
\begin{verbatim}
x = range(10) + range(3,6) + range(5,10)
r.hist(x, main='A histogram', xlab='x', col='lightblue')
\end{verbatim}
\end{framed}
If we just plot as up till now, we will get the result in an X window. We can send it to a file instead using e.g. the png() function  for bitmap PNG format or pdf()  for PDF.

\begin{verbatim}
from rpy import r

x = range(1,11)
y = [i**2 for i in x]
z = [i**3 for i in x]
r.png('output.png')
r.plot(x, y, main='My second plot', xlab='x', ylab='y', type='l', col='blue',
       ylim=r.range(y,z))
r.lines(x, z, col='red')
r.dev_off()

\end{verbatim}

The last line here closes the file we are writing the graphics to. Remember it, or the result might not be what you expect.

\subsection{Random numbers}

We can also use R to draw random numbers from a number of distributions; more than what is found in Python's own random module.

For example, to draw 10 values normally distributed around 5, with standard deviation 2, we can use
\begin{verbatim}
>>> r.rnorm(10, 5, 2)
[6.7150808154286139, 5.2738028583167056, 9.0179668220672049, 4.7356799411661843,
 10.319115043313923, 6.0269456261401189, 6.202591941969164, 6.2693086446789845,
 3.9972304190859029, 6.1397916729681894]
\end{verbatim}
The first \texttt{r} in \texttt{rnorm()} stands for "random" and indicates that we want to sample random variables. If, instead, we want the density for a list of numbers, we can use \texttt{dnorm()}:

\begin{verbatim}
>>> x = r.rnorm(10, 5, 2)
>>> r.dnorm(x, 5, 2)
[0.19429492373082802, 0.13648115130021901, 0.042525169715743855,
0.19136814419427944, 0.19502317173164863, 0.18358409741439988,
0.15662630562393501, 0.092292520327179856, 0.19700227745047683,
0.12158235704154224]
\end{verbatim}
Similarly, \texttt{qnorm()} gives us the value corresponding to a quantile (for a given q, the value x, such that $P(N <= x) = q) $ and pnorm gives us the probability (for given x, the value q, such that P(N <= x) = q).
%-----------------------------------------------------------------------------%
\newpage
\subsection{Exercise RPY.3:} Draw random values from a normal distribution and plot them using hist().

We can use this to simulate random noise around a deterministic function. That is, define some function y of x and simulate points t = y(x) + e where e is normally distributed with mean 0.

\begin{verbatim}
x = r.runif(50,0,1)                              # 50 uniform x values
y = [2*i + 3 for i in x]                         # deterministic y values
t = [i + r.rnorm(1,0,1) for i in y]              # noisy t values
r.plot(x, t, main='Noisy plot', ylab='y', xlab='x', ylim=r.range(y,t),
       col='blue', pch=20)
r.lines(x, y, col='red')
\end{verbatim}
\subsection{Exercise RPY.4} 
Generate various y functions and add noise around them. Plot the functions together with the noisy data points.

You get the residuals  the noise part of the data points  as t-y
\begin{verbatim}
res = [i-j for i,j in zip(t,y)]
\end{verbatim}

\subsection{Exercise RPY.5} 
Collect residuals from some of your simulations and plot them with \texttt{hist()}. Compare the results with RPY.3.

\subsection{Fitting linear models}

%Web-resources:
%Notes from Peter Cock.
We can also use R to do statistical modelling and model checking.
%Rpy
For data like the data we just simulated, linear normal models are appropriate.

This essentially just means coming up with a mapping from x to y, by mapping x to some linear combination of functions and then estimating the scalars of this combination.

If we believe there is a linear relationship between x and y, we map x to a combination of $w0\ast 1$ and w1x and then estimate the best choices of w by least square fitting.

If we believe there is a quadratic relationship between x and y, we map x to a combination of $w0\ast 1$, w1x, and w2x2, and then estimate the best choices of w by least square fitting.

The function \texttt{lsfit} does exactly this. It takes two input values, the model specification, let's call it phi, and the target values, the t values from above.

The model specification, phi, is a matrix with a row per data point and a column per basis vector. I.e. to fit a linear function with an intercept and a gradient, we need two columns, one that is constant 1  for the intercept  and one that is just the x value.

For simple linear regression, though, we can just use the x values, since lsfit by default includes the intercept, so the following two model fitting gives the same result:

\begin{framed}
\begin{verbatim}
from rpy import r

x = r.runif(50,0,1)
y = [.1*i**2 + 3*i - 2 for i in x]
t = [i + r.rnorm(1) for i in y]

# use default that automatically includes intercept
phi = x
w1 = r.lsfit(phi, y)['coefficients']

# explicitly construct model matrix
phi = r.matrix(0.0, nrow=len(x), ncol=2)
for i,xval in enumerate(x):
    phi[i][0] = 1                       # intercept
    phi[i][1] = xval                    # x value
w2 = r.lsfit(phi, y, intercept=False)['coefficients']

assert w1['Intercept'] == w2['X1']      # intercept is the same
assert w1['X'] == w2['X2']              # gradient is the same
\end{verbatim}
\end{framed}

For more complex model specifications, like second order polynomials, we need the matrix for:

\begin{framed}
\begin{verbatim}
from rpy import r

x = r.runif(50,0,10)
true_w = [-2, 3, .1]
y = [true_w[0] + true_w[1]*i + true_w[2]*i**2 for i in x]
t = [i + r.rnorm(1,0,10) for i in y]

phi = r.matrix(0.0, nrow=len(x), ncol=2)
for i,xval in enumerate(x):
    phi[i][0] = xval                    # x value
    phi[i][1] = xval**2                 # x^2 value
w = r.lsfit(phi, y)['coefficients']

print 'Intercept:', true_w[0], w['Intercept']
print 'First order coeficient:', true_w[1], w['X1']
print 'Second order coeficient:', true_w[2], w['X2']
But notice that we can still use the implicit intercept.
\end{verbatim}
\end{framed}

%------------------------------------------------------------------------------%
\subsubsection{Exercise RPY.6}
 Use your functions from RPY.4 and try to estimate your parameters. Plot both the true and the estimated functions. Also, try to fit the data to incorrect functions and plot the results (i.e. try fitting second order polynomials to lines or third order polynomials).

\subsubsection{Exercise RPY.7} Collect residuals for your estimated functions and plot the histograms.

Summary

We have learnt how to communicate with R from Python through the rpy module. This brings the power of R into our hands with very little effort from us.

Of course, this power is only fully realized when we know what kind of computation tasks are easy to do in R, but that is a topic for a completely different class.

Since an exercise in RPy would almost necessarily involve some more R knowledge  and since I know that you haven't finished your web-programming exercises  there won't be an exercise this week.

However, this does not mean that RPy won't show up in a mandatory project somewhere down the line...

\end{document}
% End of Document
%--------------------------------------------------%
